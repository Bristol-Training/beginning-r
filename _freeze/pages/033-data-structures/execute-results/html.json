{
  "hash": "818a86ee24959249794e92c54d4802cd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data structures\n---\n\n\n\n\n\nUntil now all the variables we have used have contained a single piece of information, for example, `a <- 4` makes a variable a containing a single number, 4. Itâ€™s very common to want to refer to collections of data. You can think, for example, of a bank statement that contains the list of expenses you had last month.\n\nR has several build-in data structures that facilitate working with this common kind of data. In this beginners course we will four of the most used data structures: `vector`, `list`, `matrix` and `data.frame`. But keep in mind there are other built-in data structures.\n\n\n### Vectors\n\nVectors are the most basic data structure in R. They are one-dimensional arrays that can hold elements of the **same data type**.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a numeric vector\nnum_vector <- c(1, 2, 3, 4, 5)\n\n# Create a vector of strings\nstr_vector <- c(\"apple\", \"banana\", \"cherry\")\n```\n:::\n\n\n\n\n\nThe elements of a vectors can be accessed using square brackets, being the first element index 1:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the third element\ncat(num_vector[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n:::\n\n\n\n\n\nAs well as being able to select individual elements from a data structure, you can also grab sections of it at once. This process of asking for subsections of a data structure of called *slicing*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the third element\ncat(num_vector[2:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2 3 4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the third element\ncat(num_vector[c(1,3,5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 3 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAddind elements in a vector can be done with the function `append`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the third element\nstr_vector <- append(str_vector, \"orange\")\ncat(str_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple banana cherry orange\n```\n\n\n:::\n:::\n\n\n\n\n\nElements can also be removed using a negative sign while indexing them, as in:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the third element\nstr_vector <- str_vector[-2]\ncat(str_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple cherry orange\n```\n\n\n:::\n:::\n\n\n\n\n\n### Matrices\n\nMatrices are two-dimensional arrays that contain elements of the **same data type**.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 3x3 matrix\nmy_matrix <- matrix(1:9, nrow = 3, ncol = 3)\n\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n\n\n\n\nElements in a matrix can be accessed using row and column indices:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(my_matrix[2, 3])  # Returns the element in the 2nd row, 3rd column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8\n```\n\n\n:::\n:::\n\n\n\n\n\nUsing the functions `rbind` and `cbind` we can add rows and columns, respectively, to a matrix.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- rbind(my_matrix, c(20,21,22))\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n[4,]   20   21   22\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- cbind(my_matrix, 31:34)\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   31\n[2,]    2    5    8   32\n[3,]    3    6    9   33\n[4,]   20   21   22   34\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also delete rows and columns using the same method that we saw for vectors.\n\n::: {#exercise-2 .callout-note title=\"Exercise\" icon=false} \nGiven the matrix below, and a column with the values `c(1, 2, 1, 2, 1)` and remove the rows 1 and 3.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an all-zero 5x5 matrix\nmy_matrix <- matrix(0, nrow = 5, ncol = 5)\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n[3,]    0    0    0    0    0\n[4,]    0    0    0    0    0\n[5,]    0    0    0    0    0\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {#answer .callout-caution icon=false title='Answer' collapse=\"true\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(0, nrow = 5, ncol = 5)\n\nmy_matrix <- rbind(my_matrix, c(1, 2, 1, 2, 1))\nmy_matrix <- my_matrix[,-c(1,3)]\n\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0    0\n[4,]    0    0    0\n[5,]    0    0    0\n[6,]    2    2    1\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n\n### Lists\n\nLists are a bit more versatile data structures as they can contain elements of **different data types**, including other lists.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n  numbers = 1:5,\n  fruit = c(\"apple\", \"banana\", \"cherry\"),\n  nested_list = list(\"a\", \"b\", \"c\")\n)\n```\n:::\n\n\n\n\n\nYou can access list elements by name or position:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(my_list$fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple banana cherry\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(my_list[[2]])  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple banana cherry\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can have as many items in a list as you like, even zero items as in:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_empty_list <- list()\ncat(my_empty_list)\n```\n:::\n\n\n\n\n\nWe can add elements to a list just by indexing a new name. For instance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[\"new_element\"] <- TRUE\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$numbers\n[1] 1 2 3 4 5\n\n$fruit\n[1] \"apple\"  \"banana\" \"cherry\"\n\n$nested_list\n$nested_list[[1]]\n[1] \"a\"\n\n$nested_list[[2]]\n[1] \"b\"\n\n$nested_list[[3]]\n[1] \"c\"\n\n\n$new_element\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can remove any element of a list assigning them the *value* `NULL`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[c(\"nested_list\",\"new_element\")] <- NULL\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$numbers\n[1] 1 2 3 4 5\n\n$fruit\n[1] \"apple\"  \"banana\" \"cherry\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Data Frames\n\nData frames are table-like structures that can contain columns of **different data types**. They are one of the most commonly used data structures for data analysis in R. **Note that all the columns in a data frame have the same number of elements**.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  name = c(\"Jean\", \"Thomas\", \"Daniel\"),\n  age = c(25, 30, 35),\n  is_student = c(TRUE, FALSE, FALSE)\n)\n```\n:::\n\n\n\n\n\nYou can access data frame columns using the `$` operator or square brackets `[]`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(df$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJean Thomas Daniel\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(df[, \"age\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n25 30 35\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also access the a data frame by rows \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(df[2, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name age is_student\n2 Thomas  30      FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\nData frames support adding new columns by passing to an assignment operation a new column name:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$height <- c(165, 180, 175)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name age is_student height\n1   Jean  25       TRUE    165\n2 Thomas  30      FALSE    180\n3 Daniel  35      FALSE    175\n```\n\n\n:::\n:::\n\n\n\n\n\nAnd adding new rows using `rbind`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- rbind(df, c(\"Patricia\",18,FALSE,160) )\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name age is_student height\n1     Jean  25       TRUE    165\n2   Thomas  30      FALSE    180\n3   Daniel  35      FALSE    175\n4 Patricia  18      FALSE    160\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n::: {#exercise1 .callout-note title=\"Exercise\" icon=false} \nGiven the below dataframe, add some more items in it:\n```\nname,   age, student\nKate,    41,   Y\nSarah,   62,   N\nMaddie,  33,   Y\nJames,   19,   Y\n```\n\nAfter, create another dataframe with only the name and student status for the first 3 person.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  name = c(\"Jean\", \"Thomas\", \"Daniel\"),\n  age = c(25, 30, 35),\n  is_student = c(TRUE, FALSE, FALSE)\n)\n```\n:::\n\n\n\n\n:::\n\n::: {#answer .callout-caution icon=false title='Answer' collapse=\"true\"}\n\n\nWe can do this in different ways, using `rbind` and adding row by row, or creating another dataframe and binding both together.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  name = c(\"Jean\", \"Thomas\", \"Daniel\"),\n  age = c(25, 30, 35),\n  is_student = c(TRUE, FALSE, FALSE)\n)\n\ndf <- rbind(df, c(\"Kate\",    41,   TRUE) )\n\nnewdata <- data.frame(\n  name = c(\"Sarah\", \"Maddie\", \"James\"),\n  age = c(62, 33, 19),\n  is_student = c(FALSE, TRUE, TRUE)\n)\n\ndf <- rbind(df, newdata)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name age is_student\n1   Jean  25       TRUE\n2 Thomas  30      FALSE\n3 Daniel  35      FALSE\n4   Kate  41       TRUE\n5  Sarah  62      FALSE\n6 Maddie  33       TRUE\n7  James  19       TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\nDataframes can index the rows and columns we want using square brakets `[rows,columns]`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- df[1:3,c(1,3)]\n\nprint(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name is_student\n1   Jean       TRUE\n2 Thomas      FALSE\n3 Daniel      FALSE\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n\n\n\n## Errors while working with data stuctures\n\nIt is very likely that indexing lists is the first time you will see a R error. Seing R errors (also sometimes called *exceptions*) is not a sign that you're a bad programmer or that you're doing something terrible. Even experienced programmers see R errors on their screen.\n\nError messages are in fact a very useful feedback mechanism for the programmer but that can be a bit daunting when you first see them. Let's recreate a typical error message: a dataframe with three columns will not have a column at index `6` (the highest index in that case would be `3`) and produce an error if we ask for it.\n\n\n\n\n\n::: {.cell filename='dataframe.R'}\n\n```{.r .cell-code}\ndf <- data.frame(\n  name = c(\"Jean\", \"Thomas\", \"Daniel\"),\n  age = c(25, 30, 35),\n  is_student = c(TRUE, FALSE, FALSE)\n)\n\ncat(df[,6])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `[.data.frame`(df, , 6): undefined columns selected\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLikewise, it will return an error if there's no matching column name.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(df[,\"Will\"])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `[.data.frame`(df, , \"Will\"): undefined columns selected\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn this last case, has two parts to it. The first is the words before the colon which tells you where the error was found. The second part of that line is usually a slightly more descriptive message, in this case telling us that the specific problem was that the column selected is not known.\n\nTake your time to read the error messages when they are printied to the screen, they will most likely help you solve the issue. If you think that you've fixed the problem but the error persists, make sure that you've saved the script file and rerun your code afterwards.\n\n\n::: {#exercise3 .callout-note title=\"Exercise\" icon=false} \nWhat happens if you try to print `df[12,6]`in the above example?\n:::\n\n::: {#answer3 .callout-caution icon=false title='Answer' collapse=\"true\"}\n\nWhen trying to access individual elements, R returns an empty object but not an error.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(df[12,6])\n```\n:::\n\n\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}