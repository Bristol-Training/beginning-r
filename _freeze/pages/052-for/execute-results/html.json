{
  "hash": "2c7a343f574a01b0175ae992155a5219",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: For loops\n---\n\n\n\n\nIt is possible to make R repeat certain lines of code using *loops*. The ability to run a line of code multiple times is the first large step on your road to making your code more *structured* and *reusable*.\n\nImagine we have three strings in a vector that we want to print. We could start by calling `cat` three times to create a program like:\n\n```{.r filename=\"loop.R\"}\nmy_words <- c(\"Jean\", \"Golding\", \"Institute\")\ncat(my_words[1])\ncat(my_words[2])\ncat(my_words[3])\n```\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nJean\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGolding\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInstitute\n```\n\n\n:::\n:::\n\n\n\n\nThis printed the output we want. But you may feel that repeating the same call to `cat` is *wasteful* code, particularly if we want to repeat the same operation for many elements. If we can manage to write that line only once then we could save ourselves some typing and potentially make the code easier to read!\n\n```\nFOR EACH word IN my_words\n    DO SOMETHING WITH word    \n```\n\nWe can write a `for` loop in R which will perform a task once for each word in our vector:\n\n\n\n\n::: {.cell filename='loop.R'}\n\n```{.r .cell-code}\nmy_words <- c(\"Jean\", \"Golding\", \"Institute\")\n\nfor (word in my_words) {\n    cat(word, \" \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nJean  Golding  Institute  \n```\n\n\n:::\n:::\n\n\n\n\nEven in this tiny example, we have ve taken a script that was four lines of code and have reduced it to three lines, and more interestingly the same loop will work no matter how many items there are in the vector `my_words`.\n\nThis maps to real life where you may want, for example, to pay for each item on your shopping list. Another way of saying that could be \"for each item on my shopping list, add its price to my total\", or as you would write that in R:\n\n```{.R}\ntotal <- 0\nfor (item in shopping_list) {\n    total <- total + item\n}\n```\n\n::: {#exercise1 .callout-note title=\"Exercise\" icon=false} \nEdit `loop.R` to have a different number of words in the vector.\n\n- Does it work if you put numbers (i.e. integers or floats) in there as well?\n- What happens if the vector `my_words` is empty? (**hint**: empty vectors look like `vec <- vector()`)\n:::\n\n::: {#answer1 .callout-caution icon=false title='Answer' collapse=\"true\"}\n\nAdding more items to the list makes the loop go around more times\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- c(\"Hello\", \"R\", \"Goodbye\", \"R\")\n\nfor (word in my_words) {\n    cat(word, \" \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello  R  Goodbye  R  \n```\n\n\n:::\n:::\n\n\n\n\nA vector cannot have a mixture of data types, so all elements are converted to strings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- c(\"Hello\", \"R\", as.numeric(404), \"Goodbye\", \"R\", 42)\n\nfor (word in my_words) {\n    cat(word, \"-\", class(word), \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello - character \nR - character \n404 - character \nGoodbye - character \nR - character \n42 - character \n```\n\n\n:::\n:::\n\n\n\n\nLooping over an empty list does not print anything\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- vector()\n\nfor (word in my_words) {\n    cat(word, \" \")\n}\n```\n:::\n\n\n\n\n\n\n:::\n\n\n::: {#keypoints .callout-tip icon=false title='`for` statement syntax'}\n\nA `for` statement has an scaffolding, the parts of the line which must always be the same and tell R that you're trying to make a loop, composed by the word `for`, the parentheses (`()`), the word `in` and the curly braces (`{}`) at the end of the line. These must always be there and in that order:\n<pre>\n<b style=\"color:darkred\">for  (</b> word <b style=\"color:darkred\">in</b> my_words<b style=\"color:darkred\"> )  {</b>\n    cat(word)\n<b style=\"color:darkred\">} </b>\n</pre>\n\nOnce the scaffolding is in place, you can place between it the things that *you* care about. The first thing to think about is the variable that you want to loop over. In our case we want to loop over the vector `my_words` because we want to print every item in that vector:\n<pre>\nfor  ( word in <b style=\"color:darkred\">my_words</b> )  {\n    cat(word)\n}\n</pre>\n\nNow we need to decide what name we want to give temporarily to each item as we get to it. As with any variable naming, it is important that we choose a good name which describe a single object from the vector. For example, if we're looping over all students in a class then we could call the variable `student` or if we're looping over a vector of ages then we could call the variable `age`. Here, since we're looping over a vector of generic *words*, we name our variable `word`:\n<pre>\nfor  ( <b style=\"color:darkred\">word</b> in my_words ) {\n    cat(word)\n}\n</pre>\n\nFinally, if we want the loop to actually *do* something then we need to give the loop a *body*. The body is the lines of code that are going to be repeated. They can be any R code but it is only within the body of the loop that we can refer to the loop variable `word`. As with `if`, it is recommended to use indentation to make it easier to identify what is in the body of the loop and what is not.\n<pre>\nfor  ( word in my_words ) {\n<b style=\"color:darkred\">    cat(word)</b>\n}\n</pre>\n\n:::\n\n\nIf we want to write more code after the end of a loop, we have to make sure that we have *closed* the curly braces. So this code will print:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- c(\"Hello\", \"R\")\n\nfor (word in my_words) {\n    cat(word, \" \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello  R  \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Goodbye \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGoodbye \n```\n\n\n:::\n:::\n\n\n\n\n\nOn the contrary, the below code will print `Goodbye` in each iteration. This is because it was inside the body of the loop.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- c(\"Hello\", \"R\")\n\nfor (word in my_words) {\n    cat(word, \" \")\ncat(\"Goodbye \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello  Goodbye R  Goodbye \n```\n\n\n:::\n:::\n\n\n\n\n\n## Loop over a range of numbers\n\nThere's a built in operator in R `:` which provides you with numbers (integers) in a range. When given two numbers, e.g. `1:10`, it will give you integers, starting from the first one and going up (*or down*) to the number you gave in second place. We can use this directly into our loop as the object to loop over and it will print:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (number in 1:10) {\n    cat(number, \" \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1  2  3  4  5  6  7  8  9  10  \n```\n\n\n:::\n:::\n\n\n\n\nWe can also loop over a range of numbers in descending order.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (number in 5:-5) {\n    cat(number, \" \")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5  4  3  2  1  0  -1  -2  -3  -4  -5  \n```\n\n\n:::\n:::\n\n\n\n\n::: {#exercise .callout-note title=\"Exercise\" icon=false} \nGiven the matrix below, write a loop that prints only the elements in columns 1 and 3, *and* rows 1 to 4..\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- t(matrix(1:25, nrow = 5, ncol = 5))\n\nprint(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[4,]   16   17   18   19   20\n[5,]   21   22   23   24   25\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {#answer1 .callout-caution icon=false title='Answer' collapse=\"true\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- t(matrix(1:25, nrow = 5, ncol = 5))\n\nfor (i in 1:4) {\n    for (j in c(1,3)) {\n        cat(my_matrix[i,j], \" \")\n    }\n    cat(\"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1  3  \n6  8  \n11  13  \n16  18  \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}